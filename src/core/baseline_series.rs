use crate::core::{DataPoint, PriceScale, TimeScale, Viewport};
use crate::error::ChartResult;
use serde::{Deserialize, Serialize};

/// Vertex in pixel coordinates used by deterministic baseline geometry output.
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct BaselineVertex {
    pub x: f64,
    pub y: f64,
}

/// Deterministic geometry for a baseline series.
///
/// `line_points` keeps the projected series line.
/// `above_fill_polygon` and `below_fill_polygon` are explicitly closed against
/// the baseline so renderer implementations can consume them directly.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct BaselineGeometry {
    pub line_points: Vec<BaselineVertex>,
    pub above_fill_polygon: Vec<BaselineVertex>,
    pub below_fill_polygon: Vec<BaselineVertex>,
    pub baseline_y: f64,
}

impl BaselineGeometry {
    #[must_use]
    pub fn empty() -> Self {
        Self {
            line_points: Vec::new(),
            above_fill_polygon: Vec::new(),
            below_fill_polygon: Vec::new(),
            baseline_y: 0.0,
        }
    }
}

/// Projects points into deterministic baseline-series geometry.
///
/// For this parity stage, above/below regions are generated by clamping line
/// vertices against the baseline and producing explicitly closed polygons.
pub fn project_baseline_geometry(
    points: &[DataPoint],
    time_scale: TimeScale,
    price_scale: PriceScale,
    viewport: Viewport,
    baseline_price: f64,
) -> ChartResult<BaselineGeometry> {
    if points.is_empty() {
        return Ok(BaselineGeometry::empty());
    }

    let baseline_y = price_scale.price_to_pixel(baseline_price, viewport)?;

    let mut line_points = Vec::with_capacity(points.len());
    for point in points {
        let x = time_scale.time_to_pixel(point.x, viewport)?;
        let y = price_scale.price_to_pixel(point.y, viewport)?;
        line_points.push(BaselineVertex { x, y });
    }

    let first_x = line_points[0].x;
    let last_x = line_points[line_points.len() - 1].x;

    let mut above_fill_polygon = Vec::with_capacity(line_points.len() + 3);
    above_fill_polygon.push(BaselineVertex {
        x: first_x,
        y: baseline_y,
    });
    above_fill_polygon.extend(line_points.iter().map(|vertex| BaselineVertex {
        x: vertex.x,
        y: vertex.y.min(baseline_y),
    }));
    above_fill_polygon.push(BaselineVertex {
        x: last_x,
        y: baseline_y,
    });
    above_fill_polygon.push(BaselineVertex {
        x: first_x,
        y: baseline_y,
    });

    let mut below_fill_polygon = Vec::with_capacity(line_points.len() + 3);
    below_fill_polygon.push(BaselineVertex {
        x: first_x,
        y: baseline_y,
    });
    below_fill_polygon.extend(line_points.iter().map(|vertex| BaselineVertex {
        x: vertex.x,
        y: vertex.y.max(baseline_y),
    }));
    below_fill_polygon.push(BaselineVertex {
        x: last_x,
        y: baseline_y,
    });
    below_fill_polygon.push(BaselineVertex {
        x: first_x,
        y: baseline_y,
    });

    Ok(BaselineGeometry {
        line_points,
        above_fill_polygon,
        below_fill_polygon,
        baseline_y,
    })
}
